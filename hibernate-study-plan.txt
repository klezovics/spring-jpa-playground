1. Simple CRUD operations (see simpleentity package)

  1.1 Include spring-data & other DB related deps into pom.xml
  1.2 Create entity
    1.2.1 @Entity, @Table (optional)
    1.2.2 @Id
    1.2.3 @Column (optional)
  1.3 Create repository
    1.3.1 @Repository, extends CrudRepository<Type, Id>
  1.4 Configure datasource spring.datasource.(url|username|password)=XXX
  1.5 spring.jpa.show-sql=true to see SQL
  1.6 Create -> repository.save();
  1.7 Read -> repository.findById();
  1.8 Update -> read from DB, set fields, call repository.save()
  1.9 Delete -> repository.delete()
  1.10 repository.exists() -> check if element exists
  1.11 repository.count() -> returns the number of records
  1.12 And in general review all the methods, which come from CrudRepository

2. Generators - how does Hibernate/DB generate primary keys (see generator package)
  2.1 On the @Id field a @GeneratedValue(strategy=GenerationType.XXX) annotation is placed
  2.2 strategy=GenerationType.AUTO -> When you use the GenerationType.AUTO,
  Hibernate selects the generation strategy (from the ones below) based on the Hibernate dialect
  2.3 strategy=GenerationType.IDENTITY -> In the SQL schema the PRIMARY KEY attribute must be configured with auto-increment option
  2.4 strategy=GenerationType.SEQUENCE -> creates a sequence in DB and uses it to get primary key
  2.5 strategy=GenerationType.TABLE -> Uses a special table to store primary keys
  2.6 Read the details about each strategy in the source code for javax.persistence.GenerationType

3. Spring Data finder methods (see product package)
   OK, so if you need a finder method to query the data by a specific field, instead
   of implementing it, you can just give it a proper name and spring will generate the code
   for you.

   See full reference here: https://www.baeldung.com/spring-data-derived-queries

4. Paging and sorting
   OK, so sometimes you want to read out your results in pages. Imagine you have 999999GB
   of data in a specific table. If you read it out all at once JVM will crash with OomError.
   Therefore, we read out the data in chunk. Each chunk is called a page. A page has a size
   and a number. You also want to sort your data by one or more fields.

   It is easy to do so with SpringData, just check this out:
   https://www.baeldung.com/spring-data-jpa-pagination-sorting

5. JPQL
6. Paging and sorting with JPQL
7. Native SQL queries
